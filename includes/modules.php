<?php
/**
 * BootPHP Modules System
 * Handles module loading and hook execution
 * Generated by installer on 2025-06-28 19:33:34
 */

/**
 * Base Module Class
 * All modules should extend this class
 */
abstract class BaseModule {
    protected $name;
    protected $settings;
    protected $enabled;

    public function __construct($name, $settings = [], $enabled = false) {
        $this->name = $name;
        $this->settings = $settings;
        $this->enabled = $enabled;
    }

    /**
     * Module initialization - override in child classes
     */
    public function init() {
        // Override in child classes
    }

    /**
     * Get module setting
     */
    protected function getSetting($key, $default = null) {
        return isset($this->settings[$key]) ? $this->settings[$key] : $default;
    }

    /**
     * Update module setting
     */
    protected function setSetting($key, $value) {
        $this->settings[$key] = $value;
        return ModuleManager::updateModuleSetting($this->name, $key, $value);
    }

    /**
     * Check if module is enabled
     */
    public function isEnabled() {
        return $this->enabled;
    }

    /**
     * Get module name
     */
    public function getName() {
        return $this->name;
    }
}

/**
 * Module Manager Class
 * Manages module loading, enabling/disabling, and hook execution
 */
class ModuleManager {
    private static $modules = [];
    private static $hooks = [];
    private static $loaded = false;

    /**
     * Load all enabled modules
     */
    public static function loadModules() {
        if (self::$loaded) {
            return;
        }

        try {
            $pdo = getDbConnection();
            $stmt = $pdo->query('
                SELECT name, title, settings, hooks, enabled 
                FROM modules 
                WHERE enabled = 1 
                ORDER BY priority ASC
            ');
            $modules = $stmt->fetchAll();

            foreach ($modules as $module_data) {
                self::loadModule($module_data);
            }

            self::$loaded = true;
        } catch (Exception $e) {
            logError('Failed to load modules: ' . $e->getMessage());
        }
    }

    /**
     * Load individual module
     */
    private static function loadModule($module_data) {
        $name = $module_data['name'];
        $module_file = BASE_PATH . '/modules/' . $name . '/' . $name . '.php';

        if (!file_exists($module_file)) {
            logError('Module file not found: ' . $module_file);
            return false;
        }

        try {
            require_once $module_file;

            $class_name = ucfirst($name) . 'Module';
            if (!class_exists($class_name)) {
                logError('Module class not found: ' . $class_name);
                return false;
            }

            $settings = json_decode($module_data['settings'], true) ?: [];
            $module = new $class_name($name, $settings, true);
            $module->init();

            self::$modules[$name] = $module;

            // Register hooks
            $hooks = json_decode($module_data['hooks'], true) ?: [];
            foreach ($hooks as $hook_name => $hook_methods) {
                if (!isset(self::$hooks[$hook_name])) {
                    self::$hooks[$hook_name] = [];
                }

                foreach ($hook_methods as $hook_method) {
                    self::$hooks[$hook_name][] = [
                        'module' => $module,
                        'method' => $hook_method['method'],
                        'priority' => $hook_method['priority'] ?? 10
                    ];
                }
            }

            // Sort hooks by priority
            foreach (self::$hooks as $hook_name => $hook_list) {
                usort(self::$hooks[$hook_name], function($a, $b) {
                    return $a['priority'] <=> $b['priority'];
                });
            }

            return true;
        } catch (Exception $e) {
            logError('Failed to load module: ' . $name . ' - ' . $e->getMessage());
            return false;
        }
    }

    /**
     * Execute hook
     */
    public static function executeHook($hook_name, $data = null) {
        if (!self::$loaded) {
            self::loadModules();
        }

        if (!isset(self::$hooks[$hook_name])) {
            return $data;
        }

        foreach (self::$hooks[$hook_name] as $hook) {
            try {
                $module = $hook['module'];
                $method = $hook['method'];

                if (method_exists($module, $method)) {
                    $data = $module->$method($data);
                }
            } catch (Exception $e) {
                logError('Hook execution failed: ' . $hook_name . ' - ' . $e->getMessage());
            }
        }

        return $data;
    }

    /**
     * Get loaded module
     */
    public static function getModule($name) {
        return isset(self::$modules[$name]) ? self::$modules[$name] : null;
    }

    /**
     * Get all loaded modules
     */
    public static function getModules() {
        return self::$modules;
    }

    /**
     * Update module setting in database
     */
    public static function updateModuleSetting($module_name, $key, $value) {
        try {
            $pdo = getDbConnection();
            $stmt = $pdo->prepare('SELECT settings FROM modules WHERE name = ?');
            $stmt->execute([$module_name]);
            $settings_json = $stmt->fetchColumn();

            $settings = json_decode($settings_json, true) ?: [];
            $settings[$key] = $value;

            $stmt = $pdo->prepare('UPDATE modules SET settings = ? WHERE name = ?');
            return $stmt->execute([json_encode($settings), $module_name]);
        } catch (Exception $e) {
            logError('Failed to update module setting: ' . $e->getMessage());
            return false;
        }
    }
}

// Convenience function for executing hooks
function executeHook($hook_name, $data = null) {
    return ModuleManager::executeHook($hook_name, $data);
}
?>